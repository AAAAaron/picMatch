#include "DBoW3/DBoW3.h"
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/features2d/features2d.hpp>
// #include <opencv2/
#include <iostream>
#include <vector>
#include <string>
#include <opencv2/imgproc.hpp>
#include <time.h>
#include "vfc.h"
using namespace cv;
using namespace std;

void mergeImage(Mat &dst, vector<Mat> &images)
{
	int imgCount = (int)images.size();
 
	if (imgCount <= 0)
	{
		printf("the number of images is too small\n");
		return;
	}
 
	printf("imgCount = %d\n", imgCount);
 
	/*将每个图片缩小为指定大小*/
	int rows = 600;
	int cols = 900;
	vector<Mat> tmpImgs;
	for (int i = 0; i < imgCount; i++)
	{	
	      Mat tmpImg(images[i]);
// 	      imshow("1111",images[i]);
	      resize(images[i], tmpImg, Size(cols, rows));//注意区别：Size函数的两个参数分别为：宽和高，宽对应cols，高对应rows
	      imshow("dsd",tmpImg);
	      tmpImgs.push_back(tmpImg);
	}
	
// 	waitKey(0); 
	/*创建新图片的尺寸
		高：rows * imgCount/2
		宽：cols * 2
	*/
	dst.create(rows * imgCount / 2, cols * 2, CV_8UC3);
 
	for (int i = 0; i < imgCount; i++)
	{
		tmpImgs[i].copyTo(dst(Rect((i % 2) * cols, (i / 2)*rows, images[0].cols, images[0].rows)));
	}
}
/***************************************************
 * 本节演示了如何根据前面训练的字典计算相似性评分
 * ************************************************/
int main( int argc, char** argv )
{
    // read the images and database  
    cout<<"reading database"<<endl;
//     DBoW3::Vocabulary vocab("./vocabulary.yml.gz");
    DBoW3::Vocabulary vocab("./vocabulary22.yml.gz");//指定自己的图片字典
//     DBoW3::Vocabulary vocab("./vocab_larger.yml.gz");  // use large vocab if you want: 
    if ( vocab.empty() )
    {
        cerr<<"Vocabulary does not exist."<<endl;
        return 1;
    }
    cout<<"reading images... "<<endl;
    vector<Mat> images; 
    RNG rng((unsigned)time(NULL));
    string testdir="/home/aaron/slambook/slambook-master/picmatch/google/";
    for ( int i=0; i<65; i++ )
    {
        string path = testdir+to_string(i)+".jpg";
// 	imshow("dsd",imread(path));
// 	waitKey(0);
        images.push_back( imread(path) );
	cout<<images.back().size()<<endl;
       
    }
    
    vector<Mat> trainimages;     
    string traindir="/home/aaron/slambook/slambook-master/picmatch/xiaomi2/";
    for ( int i=0; i<200; i++ )
    {
        string path = traindir+to_string(i)+".jpg";
// 	imshow("dsd",imread(path));
// 	waitKey(0);
        trainimages.push_back( imread(path) );
	cout<<trainimages.back().size()<<endl;
       
    }    
    
    // NOTE: in this case we are comparing images with a vocabulary generated by themselves, this may leed to overfitting.  
    // detect ORB features
    cout<<"detecting ORB features ... "<<endl;
    
    int minHessian = 400;

//     Ptr<SURF>   detector(minHessian);    
    
    Ptr< Feature2D > detector = ORB::create();
    vector<Mat> descriptors;
    vector<vector<KeyPoint>> keypoints;
    int img_index=0;
    for ( Mat& image:images )
    {        
        Mat descriptor;
	vector<KeyPoint> tmpkeypoints;
        detector->detectAndCompute( image, Mat(), tmpkeypoints, descriptor );
        descriptors.push_back( descriptor );
	drawKeypoints(image,tmpkeypoints,image,Scalar::all(-1),DrawMatchesFlags::DRAW_RICH_KEYPOINTS);
	keypoints.push_back(tmpkeypoints);
	img_index++;
    }

    vector<Mat> trainDescriptors;
    vector<vector<KeyPoint>> trainkeypoints;
    
    img_index=0;
    for ( Mat& image:trainimages )
    {
        vector<KeyPoint> tmpkeypoints;
        Mat descriptor;
        detector->detectAndCompute( image, Mat(), tmpkeypoints, descriptor );
        trainDescriptors.push_back( descriptor );
	drawKeypoints(image,tmpkeypoints,image,Scalar::all(-1),DrawMatchesFlags::DRAW_RICH_KEYPOINTS);
	trainkeypoints.push_back(tmpkeypoints);
	img_index++;
    }
    
    // we can compare the images directly or we can compare one image to a database 
    // images :
//     cout<<"comparing images with images "<<endl;
//     for ( int i=0; i<images.size(); i++ )
//     {
//         DBoW3::BowVector v1;
//         vocab.transform( descriptors[i], v1 );
//         for ( int j=i; j<images.size(); j++ )
//         {
//             DBoW3::BowVector v2;
//             vocab.transform( descriptors[j], v2 );
//             double score = vocab.score(v1, v2);
//             cout<<"image "<<i<<" vs image "<<j<<" : "<<score<<endl;
//         }
//         cout<<endl;
//     }
    
    
    
    vector<DMatch> matches;
//     FlannBasedMatcher matcher(new cv::flann::LinearIndexParams(),new cv::flann::SearchParams());
    BFMatcher matcher;
    // or with database z
    cout<<"comparing images with database "<<endl;
    DBoW3::Database db( vocab, false, 0);
    for ( int i=0; i<trainDescriptors.size(); i++ )
        db.add(trainDescriptors[i]);
    cout<<"database info: "<<db<<endl;
    for ( int i=0; i<descriptors.size(); i++ )
    {
//         string path = testdir+to_string(i)+".jpg";
      	vector<Mat> imgt;
	Mat dst;
	imgt.push_back(images[i]);  
// 	imshow("",imread(path));
        DBoW3::QueryResults ret;
        db.query( descriptors[i], ret, 3);      // max result=4
        cout<<"searching for image "<<i<<" returns "<<ret<<endl<<endl;
	for(DBoW3::Result res:ret)
	{
// 	  if(res.Score<0.035)
// 	  {
// 	    cout<<"this pic close to "<<res.Id<<"but score is low"<<endl;
// 	  }
// 	  else
// 	  {
// 	    cout<<"this pic close to "<<res.Id<<" score is "<<res.Score<<endl;
// 	  }
// 	  string path2 =traindir+to_string(res.Id)+".jpg";
// 	 cv::imshow("score="+to_string(res.Score), imread(path2) );  
// 	  cv::imshow("score=", imread(path2) );  
	  imgt.push_back(trainimages[res.Id]);
	 //考虑根据批评特性筛选是否成功 
	
	}

	matcher.match(descriptors[i],trainDescriptors[ret[0].Id],matches);
	

	//-- Step 4: Remove mismatches by vector field consensus (VFC)
	// preprocess data format
	vector<Point2f> X;
	vector<Point2f> Y;
	X.clear();
	Y.clear();
	for (unsigned int j = 0; j < matches.size(); j++) {
		int idx1 = matches[j].queryIdx;
		int idx2 = matches[j].trainIdx;
		X.push_back(keypoints[i][idx1].pt);
		Y.push_back(trainkeypoints[ret[0].Id][idx2].pt);
	}
	// main process
	double t = (double)getTickCount();

	VFC myvfc;
	myvfc.setData(X, Y);
	myvfc.optimize();
	vector<int> matchIdx = myvfc.obtainCorrectMatch();
	t = 1000 * ((double)getTickCount() - t) / getTickFrequency();
	cout << "Times (ms): " << t << endl;

	// postprocess data format
	std::vector< DMatch > correctMatches;
	std::vector<KeyPoint> correctKeypoints_1, correctKeypoints_2;
	correctMatches.clear();
	for (unsigned int j = 0; j < matchIdx.size(); j++) {
		int idx = matchIdx[j];
		correctMatches.push_back(matches[idx]);
		correctKeypoints_1.push_back(keypoints[i][idx]);
		correctKeypoints_2.push_back(trainkeypoints[ret[0].Id][idx]);
	}
	//看下矫正的match里能不能去掉一部分
	
	std::vector< DMatch > good_matches;
	for ( int j = 0; j < correctMatches.size(); j++ )
	{
	    
	    if ( correctMatches[j].distance <= 300.0)
	    {
		good_matches.push_back ( correctMatches[j] );
		printf("the %d th distance is %.3f \n",j,correctMatches[j].distance);
	    }
	}	
	
	
	
	//-- Draw mismatch removal result
	Mat img_correctMatches;
	drawMatches(images[i], keypoints[i], trainimages[ret[0].Id], trainkeypoints[ret[0].Id] ,good_matches, img_correctMatches);
	
	resize(img_correctMatches,img_correctMatches,Size(1600,800));
	//-- Show mismatch removal result
	imshow("Detected Correct Matches", img_correctMatches);
// 	waitKey(0);
	
// 	Mat img_goodmatch;
// 	drawMatches ( images[i], keypoints[i], trainimages[ret[0].Id], trainkeypoints[ret[0].Id], good_matches, img_goodmatch ,Scalar::all(-1),Scalar::all(-1));
// 
// 	resize(img_goodmatch, img_goodmatch, Size(1800, 900));
// 	imshow ( "匹配成功:优化后匹配点对"+to_string(good_matches.size()), img_goodmatch );

// 	mergeImage(dst, imgt);
// 	imshow("dst", dst);
	
	cv::waitKey(0);
	cv::destroyAllWindows();
    }
    cout<<"done."<<endl;
}